
MATH TODO:
- Implement such that I can see which weights f(t,w) are being used at each time step, and each outcome, when plotting f(t,w)Bs
- Implement example 3.1.1. Can I see that using left edge Bt as weight gives 0 on average while right edge gives T? (Stratonovic vs ito)
- Add solver types


FUNCTIONALITY TODO:
- sample many times without removing plots + Clear button
- loading symbol for simulation taking time
- get maxmu and minmu for spinboxes in processdata. CAn make it much more intuitive-
- add dashed red driftline. Should be present immediately. Also have clear where y = 0 is.
- Add dot showing the final result of sim in chart graph.
- Better to have a "GO" button for starting the sample. The settings must be clearly visible then somehow.
- Introduce SamplerMethod to SimulationParameter type. Euler–Maruyama is standard. Implement template specializations on Increment (current i euler maruyama).
	E.g. rungekutta adds this term to increment: \frac{1}{2}\left(b\left(\hat{\Upsilon}_n\right)-b\left(Y_n\right)\right)\left(\left(\Delta W_n\right)^2-\delta\right) \delta^{-1 / 2}
- inputhandler must check some logic of the query before sending it to pathengine. For instance, a mue of around 1 is crazy since that mean jumping the entire Xt each dt.


CODE DESIGN TODO:
- Stresstest to check if inputhandler can get into broken state
- Use valgrind
- Use static analyser tool
- Use sub cmakeprojects

TECH DETAILS TODO:
- Make sure old data is not leaking. Either outputmanager deletes or data saved to disc. Valgrind investigate
- use async. Transmit loading signal to OutputManager
- use threads for many paths.
- Use threadpool to avoid spinning up threads
- Maybe use more than one thread per path (for simple paths like BM). Could write function sampleRange() andattach offset to each range, where offset is previous range's last value.
